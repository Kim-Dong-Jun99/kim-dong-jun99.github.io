---
layout: post
title: rust
date: 2024-09-21 20:15 +0900
description: rust 언어 개념 & 문법 정리
image:
category: ["rust"]
tags:
published: true
sitemap: true
author: kim-dong-jun99
---

# 기본 개념

rust로 간단한 Hell world를 출력하는 프로그램은 다음과 같이 작성할 수 있습니다.
```rust
// hello_world.rs
fn main() {
    println!("Hello world");
}
```

`rustc hello_world.rs` 명령어로 생성한 rust 파일을 컴파일할 수 잇고, 컴파일하게 되면 실행 파일이 만들어집니다.

`main` 함수는 특별한 함수입니다. 모든 실행 가능한 rust 프로그램에서 실행되는 첫번째 코드입니다. 
`main` 함수를 보면 파라미터를 전달받지 않고, 아무것도 리턴하지 않는 것을 확인할 수 있습니다.

함수의 바디는 다음 코드를 포함하고 있습니다.
```rust
    println!("Hello world");
```

위 코드에서 4가지 rust의 중요한 디테일을 알 수 있습니다.
- rust에서 tab 사이즈는 4입니다.
- `println!` 은 러스트 매크로를 호출합니다. 만약 함수를 호출했다면 `println`으로 작성해야합니다. 매크로는 일반 함수와는 다른 개념입니다.
- `println!`의 파라미터로 전달한 문자열이 출력되는 것을 확인할 수 있습니다.
- 라인 끝에 세미 콜론을 포함하고 있는 것을 확인할 수 있습니다.

rust 프로그램을 실행하기 전에 `rustc`를 이용해 실행 파일을 생성햇습니다. 성공적으로 컴파일되면 실행 파일이 생성됩니다.

만약 Ruby, Python, JavaScript 같은 동적인 언어에 익숙하다면, 컴파일과 실행이 분리된 것이 익숙하지 않을 수도 있습니다.
rust는 `ahead-of-time` 컴파일 언어입니다. 프로그램을 컴파일하고, 실행 파일을 다른 사람에게 전해주면, 그 사람은 rust를 설치하지 않아도 프로그램을 실행 가능합니다.
`.rb`, `.py`, `.js` 같은 파일은 실행하기 위해서는 Ruby, Python, JavaScript가 설치되야 합니다. 하지만 하나의 명령어로 컴파일과 실행을 모두 할 수 있다는 장점이 있습니다.

`rustc`도 간단한 프로그램에서는 문제가 없지만, 큰 프로젝트에서는 `cargo`를 사용하는 것이 권장됩니다.

## cargo

`cargo`는 rust의 빌드 시스템이자 패키지 매니저입니다. rust를 사용하는 많은 사람들이 cargo를 사용하여 rust 프로젝트를 관리합니다.

앞서 작성한 프로그램은 아무런 의존성을 가지고 있지 않습니다. 
rust 프로그램이 복잡해지고 의존성이 추가될 수록, cargo로 프로젝트를 관리하는 것이 편해집니다.

`cargo new hello_cargo` 명령어로 `hello_cargo`라는 새로운 프로젝트를 생성할 수 있습니다.

새로운 프로젝트는 다음과 같은 파일들로 구성됩니다.

```text
❯ cargo new hello_cargo
    Creating binary (application) `hello_cargo` package
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
❯ cd hello_cargo
❯ ll
total 16
drwxr-xr-x   6 dongjunkim  staff  192 Sep 27 10:51 .
drwxr-xr-x   4 dongjunkim  staff  128 Sep 27 10:51 ..
drwxr-xr-x  10 dongjunkim  staff  320 Sep 27 10:51 .git
-rw-r--r--   1 dongjunkim  staff    8 Sep 27 10:51 .gitignore
-rw-r--r--   1 dongjunkim  staff   82 Sep 27 10:51 Cargo.toml
drwxr-xr-x   3 dongjunkim  staff   96 Sep 27 10:51 src
```

`Cargo.toml`파일에는 다음과 같은 내용이 작성되어 있습니다.
```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]

```

cargo의 설정 파일은 `TOML`형식으로 작성되어 있습니다.
첫번째 줄 `package`섹션에서는 패키지 관련 설정을 작성할 수 있습니다.
`name`, `version`, `edition`이 3값은 cargo가 프로그램을 컴파일하기 위해 필요한 정보입니다.

`dependencies` 섹션에서 프로젝트의 의존성을 관리할 수 있습니다.
rust에서 코드 패키지는 `crates`라고 부릅니다. 이 프로젝트에서는 다른 crates가 요구되지는 않습니다.

생성된 `src/main.rs`파일의 내용은 다음과 같습니다.

```rust
fn main() {
    println!("Hello, world!");
}
```

cargo는 소스 코드들은 `src`디렉터리에 저장합니다. 프로젝트의 탑 레벨 디렉터리에는 리드미, 라이센스 정보, 설정 파일 그리고 코드와 관련 없는 파일들을 담고 있습니다.
cargo로 프로젝트를 생성하지 않았어도, 코드를 `src` 디렉터리에 저장하고, 적합한 `Cargo.toml` 파일을 생성하면 cargo를 사용하는 것이 가능합니다.

`cargo build` 명령어를 `hello_cargo`디렉터리에서 실행하면 프로젝트가 빌드됩니다.
```text
❯ cargo build
   Compiling hello_cargo v0.1.0 (/Users/dongjunkim/rustProject/hello_cargo)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
❯ ll
total 24
drwxr-xr-x  8 dongjunkim  staff  256 Sep 27 11:05 .
drwxr-xr-x  4 dongjunkim  staff  128 Sep 27 10:51 ..
drwxr-xr-x  9 dongjunkim  staff  288 Sep 27 10:51 .git
-rw-r--r--  1 dongjunkim  staff    8 Sep 27 10:51 .gitignore
-rw-r--r--  1 dongjunkim  staff  155 Sep 27 11:05 Cargo.lock
-rw-r--r--  1 dongjunkim  staff   82 Sep 27 10:51 Cargo.toml
drwxr-xr-x  3 dongjunkim  staff   96 Sep 27 10:51 src
drwxr-xr-x@ 5 dongjunkim  staff  160 Sep 27 11:05 target
```

실행 파일은 `target/debug/hello_cargo`로 생성됩니다.

그리고 프로젝트를 빌드한 결과 `Cargo.lock` 파일이 생성된 것을 확인할 수 있습니다. 이 파일은 프로젝트 의존성의 버전 정보를 관리합니다.
개발자가 직접이 lock 파일을 다루지 않아도 cargo가 알아서 관리해줍니다.

`cargo build && ./target/debug/hello_cargo` 명령어로도 실행가능하지만, `cargo run` 하나의 명령어로도 코드를 컴파일하고, 실행 파일을 실행 가능합니다.

`cargo check` 명령어로는 실행 파일을 생성하지 않고, 컴파일 되는 것을 확인 가능합니다. `cargo check`은 실행 파일을 만들지 않기에, 빌드 명령어보다 훨씬 빠르게 동작합니다.

만약 프로젝트가 배포할 준비가 되었다면, `cargo build --release` 명령어로 최적화된 컴파일을 할 수 있습니다.
`cargo build --release` 명령어는 실행 파일은 `target/release` 디렉터리에 생성합니다. 최적화된 컴파일은 rust 코드의 실행 시간을 줄여주지만,
컴파일되는데는 더 많은 시간이 필요합니다.
그렇기에 프로필이 분리된 것입니다. 
개발 과정에서는 자주 빠르게 빌드하고, 운영 환경에서는 빠르게 빌드되지는 않더라도 빠른 실행 시간을 확보합니다.


## variables

rust에서 기본적으로 변수는 불변입니다. rust는 동시성 제어 그리고 코드의 안전성을 보장하기 위해 변수를 불변으로 관리합니다.
하지만 변수를 가변적으로 생성할 수도 있습니다.

불변인 변수는 값을 재할당 받을 수 없습니다.
다음 코드는 에러가 발생합니다.
```rust
fn main() {
  let x = 5;
  println!("x is {x}");
  x = 6;
  println!("x is {x}");
}
```

발생한 컴파일 타임 에러 메세지입니다.

`error[E0384]: cannot assign twice to immutable variable 'x'`

불변인 변수에 값을 변경하려고 할 때 컴파일 타임 에러가 발생하는 것은 매우 중요합니다. 왜냐하면 이 상황이 버그로 이어질 수 있기 때문입니다.
rust 컴파일러는 불변으로 선언한 변수의 값이 변하지 않는 것을 보장합니다.

변수의 가변성이 편리하고 코드 작성을 편하게 해주는 부분도 존재합니다. 기본적으로 rust 변수는 불변이지만, `mut`를 추가하는 것으로 가변 변수로 선언할 수 있습니다.
```rust
fn main() {
  let mut x = 5;
  println!("x is {x}");
  x = 4;
  println!("x is {6}");
}
```

불변 변수와 비슷한 `constants`도 존재합니다. 불변 변수와 동일하게 값을 변경할 수 없지만, 몇가지 차이점도 존재합니다.

1. constants에서는 `mut`를 사용할 수 없습니다.
  - const는 기본적으로 불변인 것이 아니라 항상 불변입니다.
  - `const` 키워드를 이용해 constants를 선언할 수 있고, 타입을 명시해야합니다.
2. constants는 어떤 스코프에서도 선언 가능합니다.
3. constants는 어떤 상수 표현을 저장합니다. 런타임 실행의 결과를 저장하는 용도로는 사용하지 않습니다.

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

rust 네이밍 컨벤션에서 constants는 대문자 그리고 단어 사이는 underscore로 채우는 것을 권장합니다.

## shadowing

이전에 선언한 변수명과 동일한 변수를 선언할 수 있습니다. 
shadowing 예시는 다음과 같습니다.
```rust
fn main() {
    let x = 5;

    let x = x + 1;
    {
        let x = x* 2;
        println!("x is {x}");
    }
    println!("x is {x}");
}
/*
x is 12
x is 6
*/
```
x의 초기값은 5입니다. 그리고 새로운 x는 x+1 = 6의 값을 가집니다. 
이너 스코프에서 x는 x*2 = 12의 값을 가지고, 이너 스코프가 끝나며 쉐도잉이 해제되어 x는 다시 6의 값을 가집니다.

쉐도잉은 `mut`을 이용해서 변수를 가변으로 만드는 것과는 다릅니다. `let` 키워드를 사용하지 않으면 값을 변경할 수 없기 때문입니다.

`mut`과 쉐도잉의 또 다른 차이점은 쉐도잉은 새로운 변수를 생성하는 것이기에 동일한 이름의 변수로 다른 타입의 값을 저장할 수 있습니다.
```rust
let spaces = " ";
let spaces = spaces.len();

let mut spaces = " ";
spaces = spaces.len(); // spaces가 문자열 타입으로 지정되었기에, 타입 미스매치로 할당이 불가합니다.
```

## data types

rust는 정적인 타입 언어입니다. 모든 변수의 타입은 컴파일 시점에 정해져야합니다. 
```rust
let guess: u32 = "42".parse().expect(" not a number ");
```
위 코드에서 `: u32`를 제거하면 오류가 발생합니다. 어느 타입으로 `parse()`할지 알 수 없기 때문입니다.

rust에서는 두가지 타입 서브셋이 존재합니다 : **scalar & compound**

**scalar types**

스칼라 타입은 단일 값을 나타냅니다. rust는 4가지 스칼라 타입을 가집니다. : integers, floating-point numbers, Booleans, characters

rust에서 integer type은 다음과 같습니다.

|length|signed|unsigned|
|------|------|--------|
| 8 bit | i8 | u8 |
| 16 bit | i16 | u16 |
| 32 bit | i32 | u32 |
| 64 bit | i64 | u64 |
| 128 bit | i128 | u128 |
| arch | isize | usize |

`isize`와 `usize` 자료형은 실행중인 컴퓨터의 아키텍쳐에 따라 정해집니다. 64 비트인 경우 64비트로, 32비트인 경우 32비트로 정해집니다.

> Integer overflow        
> `u8` 타입 변수는 0 ~ 255 값을 저장할 수 있습니다. 256 같은 값을 저장하려고하면 *integer overflow*가 발생합니다.

rust에서는 두가지 소수 자료형이 있습니다. `f32`, `f64`입니다. 기본적으로 `f64`가 할당되고, `f32`는 명시적으로 할당해서 지정 가능합니다.
```rust
fn main() {
  let x = 2.0; // f64
  let y: f32 = 3.0 // f32
}
```

boolean 타입과 character 타입은 다음과 같이 사용 가능합니다.
```rust
fn main() {
  let t = true;
  let f: bool = false;

  let c = 'c';
  let z: char = 'z';
}
```

**compound types**

컴파운드 타입은 여러 개의 값을 그룹핑하는 타입입니다. rust에는 두가지 컴파운드 타입이 존재합니다 : tuple & array

tuple은 여러 개의 다양한 타입의 값을 묶는 방법 중 하나입니다. 
tuple은 고정된 길이를 가집니다. 선언된 이후 줄어들거나 늘어날 수 없습니다.
다음과 같이 타입을 명시해서 사용할 수 있습니다.
```rust
fn main() {
  let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

`tup` 의 값을 다음과 같이 분해할 수도 있습니다.
```rust
fn main() {
  let tup = (500, 6.4, 1);
  let (x, y, z) = tup;
  println!("y is {y}");
}
```

다음처럼 tuple의 인덱스를 통해서 값을 꺼내올 수 있습니다.
```rust
fn main() {
  let x = (500, 6.4, 1);
  let five_hundred = x.0;
  let six_point_four = x.1;
  let one = x.2;
}
```

아무런 값을 포함하지 않는 tuple은 `unit`이라고 부릅니다. `unit`은 빈 값을 대표하고, `unit`을 리턴한다는 것은 빈 값을 리턴하는 것과 같습니다.

다른 컴파운드 타입으로는 array가 있습니다. tuple과는 다르게 array는 모든 엘리멘트들이 같은 타입입니다. 

```rust
fn main() {
  let a = [1, 2, 3, 4, 5];
}
```

array는 힙보다 스택에 데이터를 저장하고 싶을 때 혹은 고정된 길이의 데이터를 다룰 때 유용합니다.
array는 vector처럼 유연하지 않습니다. vector는 비슷한 컬렉션 타입이지만 사이즈를 줄이거나 키울 수 있습니다.

array의 타입은 다음과 같이 명시할 수 있습니다.
```rust
fn main() {
  let a: [i32; 5] = [1, 2, 3, 4, 5];
}
```
`i32`는 array element의 자료형을 명시하고, 5로 배열의 크기를 지정했습니다.

같은 값을 가지는 배열을 다음과 같이 선언할 수 도 있습니다.
```rust
fn main() {
  let a:[3; 5]; // [3, 3, 3, 3, 3]
}
```

배열 엘리멘트의 접근은 다음과 같이 할 수 있습니다.
```rust
fn main() {
  let a = [1, 2, 3, 4, 5];
  let first = a[0];
  let second = a[1];
}
```

## functions

rust 컨벤션으로 함수 명과 변수명은 snake case로 작성합니다. 모든 글자는 lowercase로 작성하고, 단어는 underscore로 구분합니다.

```rust
fn main() {
  println!("hello world");

  another_function();
}

fn another_funcion() {
  println!("another function");
}
```

rust에서 새로운 함수는 `fn` 키워드를 이용해서 정의합니다. 

rust에서 함수 선언 위치는 중요하지 않습니다. `another_function`이 main 함수 다음에 선언된 것을 확인할 수 잇씁니다.

다음과 같이 함수는 파라미터를 가질 수 있습니다. 파라미터로 넘어가는 실제 값을 argument라고 부릅니다.

```rust
fn main() {
  another_function(5);
}

fn another_function(x: i32) {
  println!("x is {x}");
}
```

함수의 시그니처에서 파라미터의 타입은 필수적으로 선언해야합니다. 

```rust 
fn main() {
  print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
  println!("measurement is {value}{unit_label}");
}
```

함수의 바디는 statements 들로 구성되고 선택적으로 expression으로 종료됩니다. 지금까지 작성한 함수들은 expression을 가지지 않았습니다.
하지만 expression을 statement의 일부로 작성했습니다. rust는 expression 에 기반한 언어이기에 둘의 차이점을 아는 것이 중요합니다.
- statement : 어떤 행동을 하고 값을 리턴하지 않는 명령어
- expression : 어떤 값을 리턴하는 코드

지금까지 이미 statement와 expression을 사용해봤습니다.
변수를 생성하고, 변수에 값을 할당하는 것은 statement입니다.
statement는 값을 리턴하지 않기에 다음 코드는 에러가 발생합니다.
```rust
fn main() {
  let x = (let y = 6);
}
```

`let y = 6` statement는 어떤 값을 리턴하지 않기에 `x`에 어떤 값을 bind할 수 없습니다. Ruby나 C에서는 `x = y = 6` 같이 사용가능한데, rust에서는 불가합니다.

expression은 어떤 값을 가지는 표현입니다. 다음과 같은 수식 `5+6`은 `11`이라는 값을 가집니다.. 
`6`이라는 statement는 expression입니다. `let y = 6`에서 `6`이라는 값을 나타냅니다.
함수를 호출하는 것은 expression이고 macro를 호출하는 것도 expression입니다.
새로운 스코프 블록도 expression입니다.
```rust
fn main() {
  let y = {
    let x = 3;
    x + 1
  };
  println!("y is {y}");
}
// y is 4
```

새로운 스코프 블록에서 `x+1`은 세미콜론으로 끝나지 않습니다. expression은 세미콜론을 포함하지 않습니다. 만약 세미콜론을 추가하게되면, statement로 동작하고, 어떤 값을 리턴하지 않습니다.

함수는 어떤 값을 리턴할 수 있습니다. 리턴할 값의 타입을 `->`로 명시할 수 있습니다.
rust에서 함수의 리턴 값은 함수 바디의 마지막 expression과 동일합니다. `return`키워드와 리턴 값을 명시해서 일찍 리턴할 수도 있지만, 대부분의 함수가 암시적 리턴을 사용합니다.

```rust
fn five() -> i32 {
  5
}

fn main() {
  let x = five();
  println!("x is {x}");
}
```

`five()` 에서 마지막 expression이 리턴되고 `x is 5`가 출력됩니다.

## control flow

**if**

rust에서 조건문은 다음과 같이 사용 가능합니다.
```rust
fn main() {
  let number = 6;

  if number % 4 == 0 {
    println!("number is divisible by four");
  } else if number % 3 == 0 {
    println!("number is divisible by three");
  } else {
    println!("number is not divisible by four or three");
  }
}
```

`if`가 expression 이기에 다음과 같이 사용할 수도 있습니다.
```rust
fn main() {
  let condition = true;
  let number  = if condition {5} else {6};
  println!("number is {number}");
}
// number is 5
```

이때 주의해야할 점은 `if`그리고 `else`에서 expression 타입이 동일해야합니다. 타입이 다르면 에러가 발생합니다.

**loop**

rust에서는 3가지 종류의 반복문이 존재합니다 : `loop`, `while`, `for`

`loop`키워드는 명시적으로 반복문을 벗어나기 전까지 무한히 반복합니다.
```rust
fn main() {
  loop {
    println!("again!");
  }
}
```

위 코드를 실행해보면, 실행을 종료하기 전까지 무한히 출력되는 것을 확인할 수 있습니다.

이외에도 `break` 문을 사용해서 반복문을 벗어나게 설정할 수도 있습니다.

`loop`의 사용 방법 중 하나는 실패할 수도 있는 작업을 재시도하는 거나 반복문의 결과를 리턴 받는 것입니다.
반복문의 결과를 리턴받기 위해선 `break`문 다음에 리턴 받을 값을 명시하는 것으로 결과를 리턴 받을 수 있습니다.
```rust
fn main() {
  let mut count = 0;
  let result = loop {
    count += 1;
    if count == 10 {
      break count * 2;
    }
  }
  println("result is {result}");
}
// result is 20
```

반복문 이전에 `count`라는 변수를 선언하고 0으로 초기화했습니다. `result`라는 변수를 선언하고, `loop`에서 리턴한 값을 `result`에 저장합니다.
매 반복마다 `count` 변수는 1 증가하고, `count`값이 10에 도달한 순간 `break`키워드가 실행되고 20이 리턴되기에 `result`변수는 최종적으로 20이라는 값을 가집니다.

내부 반복문을 사용할 때, `break`와 `continue`는 가장 내부 반복문에 적용됩니다. `loop label`을 명시해서 가장 내부 반복문 말고 `break`와 `continue`를 실행할 반복문을 지정할 수 있습니다.
```rust
fn main() {
  let mut count = 0;
  'counting_up: loop {
    println!("count = {count}");
    let mut remaining = 10;

    loop {
      println!("remaining = {remaining}");
      if remaining == 9 {
        break;
      }
      if count == 2 {
        break 'counting_up;
      }
      remaining -= 1;
    }
    count += 1;
  }
  println!("end count = {count}");
}
/*
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
end count = 2

*/
```
count 변수 값이 2이자, 내부 반복문에서 `break 'counting_up`이 실행되어 외부 반복문에서도 바로 벗어난 것을 확인할 수 있습니다.

rust에서 while 문은 다음과 같이 사용가능합니다.
```rust
fn main() {
  let mut number = 3;
  while number != 0 {
    println("{number}")
    number -= 1;
  }
}
```

for 문을 이용해서 다음과 같이 컬렉션을 순회할 수도 있습니다. 
```rust
fn main() {
  let list = [1, 2, 3, 4, 5];
  for l in list {
    println!("l is {l}");
  }
}
```

명확한 실행 종료 조건이 있지 않는 경우 반복문은 for 문을 쓰는 것이 안전합니다. 특정 범위의 수를 반복하는 반복문은 다음과 같이 사용 가능합니다.
```rust
fn main() {
  for i in 1..4 {
    println!("ascending {i}");
  }

  for i in (1..4).rev() {
    println!("descending {i}");
  }
}
/*
ascending 1
ascending 2
ascending 3
descending 3
descending 2
descending 1
*/
```

## ownership

ownership은 rust 프로그램이 메모리를 관리하는 것과 관련된 몇 가지 규칙들입니다. 
모든 프로그램은 실행중에 컴퓨터 메모리를 어떻게 사용할 것인지를 관리해야합니다.
몇몇 언어들은 가비지 컬렉션을 사용해서 프로그램 실행중에 종종 더이상 사용되지 않는 메모리를 확인합니다.
다른 언어들은 프로그래머가 명시적으로 메모리의 할당과 해제를 관리해아합니다.
rust는 또 다른 방법을 사용합니다.

rust에서 메모리는 시스템의 ownership을 통해 관리됩니다. 시스템의 ownership은 컴파일러가 확인하는 몇가지 규칙들을 기반해서 동작합니다.
만약 위반된 규칙이 있다면, 프로그램은 컴파일되지 않습니다. 

ownership은 많은 프로그래머들에게 새로운 개념이기에 익숙해지기 위한 시간이 필요합니다. rust와 ownership의 규칙에 익숙해질 수록 안전하고 효율적인 코드를 작성할 수 있습니다.

> **stack과 heap**       
> 많은 프로그래밍 언어들이 stack과 heap에 대해서 생각하게 하지 않습니다.
> 하지만 rust에서는 값이 stack에 있는지, heap에 있는지가 언어의 행동 방식에 영향을 미칩니다.
>
> stack과 heap은 모두 런타임에 사용할 수 있는 메모리의 일부분입니다. 하지만 둘은 다른 방식으로 구성되어있습니다.
>
> stack은 lifo 방식으로 동작합니다. stack에 저장되는 모든 데이터는 고정된 사이즈를 가져야합니다. 컴파일 시점에 데이터 크기를 알 수 없거나 사이즈가 변할 수 있는 데이터는 heap에 저장되어야합니다.
>
> heap에 데이터를 저장할 때는 특정 용량의 요청합니다. memory allocator가 heap에서 빈 공간을 찾고, 해당 공간을 사용중 처리한 다음 포인터를 리턴합니다.
> 포인터는 빈 공간의 주소 값입니다. 
>
> 이 과정을 allocating on the heap 이라고 하며 allocating이라고 줄여서 부르기도합니다. heap의 포인터 자체는 고정된 크기이기에 stack에 포인터를 저장할 수 있습니다.
> 하지만 만약 실제 데이터를 원한다면, 포인터를 통해서 실제 데이터에 접근해야 합니다.
> 식당을 예시로 heap의 메모리 할당 과정을 살펴보면 다음과 같습니다.
> 식당에 입장해 인원 수를 몇 명 왔는지 설명 == allocator에게 특정 용량의 데이터를 요청
> 식당 호스트가 자리로 안내 == allocator가 빈 공간을 찾고 포인터를 리턴
>
> stack에 push하는 것이 heap allocating 하는 것보다 빠릅니다. 왜냐하면 allocator가 빈 공간을 찾을 필요가 없기 때문입니다.
> stack에 push는 항상 stack의 top에 하면 되기에 속도가 더 빠릅니다.
> 그리고 allocator가 요청한 데이터를 저장할 수 있는 빈 공간을 찾아야 하기에 더 오랜 시간이 필요합니다.
>
> heap에 있는 데이터를 접근하는 것이 stack 데이터를 접근하는 것보다 느립니다.
> 우선 포인터 변수에 접근해서 주소 값을 가져와야 하기에 더 느립니다. 현대 프로세서들은 메모리에 덜 이동할 수록 더 빠르게 동작합니다.
> 식당 예시를 이어서 설명하면, A 테이블에서 주문을 받고 B 테이블 주문을 받고 다시 A 테이블에 와서 이어서 주문을 받고 다시 B 테이블로 이동하는 것은 
> 긴 시간을 필요로 할 것입니다.
>
> 코드가 함수를 호출하면, 값은 함수로 전달됩니다. 그리고 함수의 지역 변수들은 stack에 push됩니다. 함수가 종료되면, 값은 stack에 pop되어서 사라집니다.
> 코드가 heap에서 어떤 데이터를 사용하는지, heap에서 중복 데이터를 어떻게 줄일지, heap에서 사용하지 않는 데이터를 어떻게 지울지 등등이 모두 ownership이 다루는 것들입니다.
> ownership에 대해서 이해하게되면, stack와 heap에 대해서 크게 신경 쓰지 않아도 무방합니다.

ownership rule들은 다음과 같습니다. 
- rust에서 value들은 owner를 가진다.
- 하나의 owner만 존재 가능하다.
- owner가 스코프 바깥으로 사라진다면, value는 drop된다.

### variable scope

변수의 스코프는 아이템이 유효한 범위입니다.

변수의 스코프는 다음과 같이 설정됩니다.
```rust
{ // s 가 아직 선언되지 않았습니다.
  let s = "hello"; // s는 이후부터 유효 합니다.

  // ~~ s로 어떤 작업을 처리
} // 스코프가 종료되기에 s 는 더 이상 유효하지 않습니다.
```

스코프에서 중요한 포인트는 다음과 같습니다.
- s가 스코프 내부로 들어오면, valid입니다.
- 그리고 스코프가 종료될 때 까지 valid합니다.


여기까지는 다른 언어에서의 스코프와 변수의 개념과 동일합니다.

### String type

ownership의 규칙을 설명하기 위해서는 앞서 다뤘던 데이터 타입보다 복잡한 데이터 타입이 필요합니다.
앞서 학습한 데이터 타입들은 모두 크기가 정해진 데이터 타입들이였습니다. 
그렇기에 스코프가 종료되면 stack에서 pop되고 다른 스코프에서 동일한 값을 사용해야한다면 쉽게 독립적인 인스턴스를 만들 수 있습니다.

String type은 heap에 저장되는 데이터 입니다. String type을 통해 ownership의 규칙을 알아볼 수 있습니다.
이전 예시에서 부터 하드 코딩된 문자열 값을 다룬 적이 있습니다.
```rust
fn main() {
  let hw = "hello world";
  println!("{hw}");
}
```
이런 하드 코딩된 문자열 값은 유용하지만, 텍스트를 다루는 모든 상황에서 유용하지는 않습니다. 
그 이유 중 하나는 문자열은 불변이라는 점입니다. 또 모든 문자열 값이 코드를 작성할 때 알 수 있지는 않습니다.
사용자의 입력을 받아서 문자열 변수에 저장하려고 할 때, 사용자가 어떤 문자열을 입력할지 미리 알 수는 없습니다.

이런 상황들에 대응하기 위해서 `String`타입이 존재합니다. 이 타입은 heap에 allocated된 데이터를 관리합니다. `String` 타입 데이터는 다음과 같이 생성 가능합니다.
```rust
let s = String::from("hello");
```

위와 같은 방식으로 생성된 string은 변형 가능 합니다.
```rust
let mut s= String::from("hello");
s.push_str(", world");
println!("{s}"); // hello, world
```

왜 `String::from`으로 생성된 문자열은 변형 가능하고, 하드 코딩된 문자열 값은 변형 불가능한 것일까요?
차이점은 두 타입이 메모리를 다루는 방식입니다.

문자열 구문 같은 경우 컴파일 시점에 문자열의 내용을 알 수 있습니다. 그렇기에 텍스트 내용이 실행 파일로 하드 코딩됩니다.
문자열 구문이 빠르고 효율적인 이유가 여기에 있습니다. 이런 장점은 문자열 구문이 불변인 것에 기초합니다.
불행히도 실행 파일에 런타임에 크기가 변할 수도 있는 크기의 메모리 할당을 명령하는 것은 불가능합니다.

가변적인 문자열 사용을 위한 `String`타입은 컴파일 시점에 알지못하는 데이터를 저장하기 위해 heap에 특정 크기의 memory를 allocate합니다.
- 런타임에 memory allocator에 의해 메모리를 요청해야합니다.
- 문자열을 다 쓴 다음에 이 문자열이 점유한 메모리를 해제해야합니다.

첫번째 단계는 개발자에 의해 실행됩니다. `String::from`을 호출할 때 필요한 메모리를 요청합니다. 이는 프로그래밍 언어에서 모두 공통적으로 동작합니다.

두번째 단계는 다릅니다. 
가비지 컬렉터를 사용하는 언어 같은 경우에는 가비지 컬렉터가 더 이상 사용하지 않는 메모리를 제거합니다.
가비지 컬렉터가 사용하지 않는 메모리를 해제하기에 개발자는 신경 쓰지 않아도 됩니다. 가비지 컬렉터가 없으면 개발자가 명시적으로 메모리를 해제해야합니다.

역사적으로 개발자가 직접 메모리를 해제하는 것은 어려운 일이었습니다. 만약 메모리 해제 작업을 까먹으면 메모리가 낭비될 것입니다. 
만약 너무 빨리 해제하면 변수는 유효하지 않게됩니다. 그리고 실수로 두번해제하게 되는 상황에서는 버그가 발생합니다. `allocate`과 `free`는 1대1 대응되야합니다.

rust는 다른 접근 방법을 사용합니다. 메모리는 변수가 스코프 바깥으로 벗어나는 순간 해제됩니다. 
```rust
{
  let s = String::from("hello"); // s는 이 시점 이후로 스코프에서 유효합니다.
  // s를 이용하여 어떤 작업 처리
} // 스코프가 종료되고, s는 이 시점 이후로 유효하지 않습니다.
```

`s`가 스코프에서 벗어나는 순간 rust는 `drop`이라는 특별한 함수를 호출합니다. rust는 `{}`가 닫힐때마다 자동으로 `drop`을 호출합니다.
간단하게 동작하는 것 같지만, 다양한 변수가 heap에 allocate된 상황에서는 예상치 못하게 동작하는 경우도 있습니다.

### variables and data interacting with move

동일한 데이터를 다루는 다양한 변수는 rust에서는 좀 다르게 동작합니다.
```rust
let x = 5;
let y = x;
```

위 코드의 동작을 예상해보면, 우선 `x`에 5를 할당하고, `x`의 값을 복사해서 `y`에 할당합니다. 
결과적으로 `x`와 `y`는 같은 값을 가집니다. 코드는 예상대로 동작하고, 그 이유는 integer가 simple value이기 때문입니다.

`String`의 경우를 생각해보면,
```rust
let s1 = String::from("hello");
let s2 = s1;
```
integer에서 다룬 예시와 비슷하기에, 동작 방식도 유사하다고 생각할 수 있습니다.
`s1`의 값을 복사해서 `s2`에 전달한다고 생각 할 수도 있지만, 실제 동작은 그렇지 않습니다.

![https://doc.rust-lang.org/book/img/trpl04-01.svg](https://doc.rust-lang.org/book/img/trpl04-01.svg)

`String` 내부 동작을 위 그림에서 확인할 수 있습니다. `String`은 3가지 구성 성분을 가지고 있습니다.
string의 데이터를 담고 있는 메모리 포인터, length 그리고 capacity 입니다.
왼쪽 데이터들은 stack에 저장되고 오른쪽 데이터들은 heap에 저장된 데이터입니다.

length란 바이트 단위로 `String`의 컨텐츠가 사용하고 있는 메모리 양을 의미합니다.
capacity는 바이트 단위로 `String`이 allocator로부터 할당 받은 메모리 크기를 의미합니다.
> go 에서 slice length, capacity 개념과 유사합니다.

`s1`을 `s2`에 할당하면, `String`의 데이터는 복사됩니다. 다시 말해 stack의 저장된 포인터, length, capacity 값이 복사됩니다.
그 결과 다음 그림 같은 메모리 구조가 구성됩니다.
![https://doc.rust-lang.org/book/img/trpl04-02.svg](https://doc.rust-lang.org/book/img/trpl04-02.svg)

`s1`과 `s2`가 같은 메모리 주소를 point하고 있는 것을 알 수 있습니다. rust는 아래와 같이 동작하지 않습니다.
![https://doc.rust-lang.org/book/img/trpl04-03.svg](https://doc.rust-lang.org/book/img/trpl04-03.svg)

위와 같이 동작했다면, `s2 = s1`같은 연산은 매우 비싼 연산일 것입니다. heap에 저장하고 있는 데이터의 크기가 매우 크다면 복사해야할 데이터 양이 매우 크기 때문입니다.

앞서서 변수가 스코프 범위에서 벗어난다면, `drop`함수가 호출되어서 해당 변수의 heap 메모리를 제거한다고 했었는데, `s2 = s1` 같은 상황에서 두 변수는 같은 데이터 포인터를 가리키고 있습니다.
그렇기에 `drop`함수가 호출되면 두 변수 모두 같은 메모리 해제 요청이 발생해서 double free error가 발생합니다.
메모리를 보호하기 위해 `let s2 = s1;` 이 호출되면, rust는 그 시점부터 `s1`을 유효하지 않다고 판단합니다. 그렇기에 함수 스코프가 종료될 때, `s1` 메모리는 해제하려고 하지 않습니다.

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("s1 is {s1}");
}
```

위 rust 파일을 컴파일하게 되면 다음 같은 오류가 발생하는 것을 확인할 수 있습니다.
```text
warning: unused variable: `s2`
 --> ownership.rs:3:9
  |
3 |     let s2 = s1;
  |         ^^ help: if this is intentional, prefix it with an underscore: `_s2`
  |
  = note: `#[warn(unused_variables)]` on by default

error[E0382]: borrow of moved value: `s1`
 --> ownership.rs:5:21
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("s1 is {s1}");
  |                     ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

error: aborting due to 1 previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0382`.
```

shallow copy, deep copy 라는 개념을 다른 프로그래밍 언어를 공부하면서 들어봤다면, heap 데이터 자체를 복사하는 것이 아니라 stack의 데이터 포인터, length, capactiy를 복사하는 것이 shallow copy처럼 느껴집니다.
하지만, rust는 shallow copy를 하는 것이 아니라, 첫번째 변수를 무효화처리하기에, `move`를 한다고 할 수 있습니다.

rust에서 `move`를 나타내는 그림은 다음과 같습니다.
![https://doc.rust-lang.org/book/img/trpl04-04.svg](https://doc.rust-lang.org/book/img/trpl04-04.svg)

`s1`이 `s2`로 `move`되면서 double free error는 발생하지 않습니다. 
> 추가적으로 rust는 이렇게 동작하기에 절대 데이터를 deep copy하지 않습니다.

만약 `String`의 데이터를 deep copy하고 싶다면, `clone`이라는 공통 메서드를 사용할 수 있습니다. 
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 is {s1}, s2 is {s2}");
}
// s1 is hello, s2 is hello
```

`clone`을 통해 heap 데이터를 deep copy하였기에 컴파일 되지 않던 코드가 정상적으로 컴파일되고 실행되는 것을 확인할 수 있습니다.

### stack-only data : copy

다음 코드는 정상적으로 동작합니다.
```rust
let x = 5;
let y = x;

println!("x = {x} y = {y}");
```

하지만 방금 전까지 배운 개념과는 약간 모순되게 느껴지긴 합니다. `clone`을 호출하지 않았는데도, `x`는 유효하고, `y`로 `move`되지 않았습니다.

그 이유는 integer 같은 타입은 컴파일 시점에 크기를 알 수 있기에 stack에 저장되고, 실제 값 복사를 빠른 시간에 할 수 있습니다. 
그렇기에 `x`를 무효화해야할 이유가 없습니다. 다른 말로 하면 deep copy, shallow copy 간 차이점이 없습니다. `clone`을 호출하는 것과 다른게 없습니다.

rust에는 `Copy` 트레이트라는 특별한 주석이 있습니다. 
이 주석은 정수와 같이 스택에 저장되는 타입에 사용할 수 있습니다(트레이트에 대해서는 이후 더 자세히 다룰 예정입니다). 
만약 어떤 타입이 `Copy` 트레이트를 구현하면, 그 타입을 사용하는 변수는 이동하지 않고 간단히 복사됩니다. 
따라서 다른 변수에 할당된 후에도 여전히 유효합니다.

rust에서는 타입이나 그 일부가 `Drop`트레이트를 구현한 경우, 해당 타입에 `Copy` 주석을 추가하는 것을 허용하지 않습니다.
만약 타입이 스코프를 벗어날 때 특별한 처리가 필요하고, 그 타입에 `Copy` 주석을 추가하 컴파일 시간에 오류가 발생하게 됩니다.

`Copy`를 구현한 타입이 궁금하다 주어진 타입의 공식 문서를 확인할 수 있습니다. 
`Copy`를 구현한 타입은 다음과 같습니다.
- 모든 정수 타입, `u32`
- boolean 타입, `bool`
- 모든 소수 타입, `f64`
- 문자 타입 `char`
- 만약 튜플안 모든 타입이 `Copy`를 구현했다면 튜플, `(i32, i32)`


### ownership & functions

함수에 값을 전달하는 메커니즘은 변수에 값을 할당하는 메커니즘과 유사합니다. 
함수에 변수를 전달할 때 `move` 되거나, `copy`됩니다.

```rust
fn main() {
  let s = String::from("hello"); 

  takes_ownership(s); // s의 ownership이 takes_ownership으로 move됩니다.

  let x = 5;

  makes_copy(x); // copy로 동작하기에 이후에 x를 사용 가능합니다.
}

fn takes_ownership(some_string: String) {
  println!("{some_string}");
} // 스코프가 종료되며 s가 보유한 메모리가 해제됩니다.

fn makes_copy(some_integer: i32) {
  println!("{some_integer}");
}
```

`s`를 `takes_ownership`을 호출한 다음 사용하려면, 오류가 발생합니다. `takes_ownership`을 호출할 때, `s`의 ownership이 `move`되기 때문입니다.

### return values and scope

값을 리턴하는 것 역시 ownership을 이전합니다.

```rust
fn main() {
  let s1 = gives_ownership(); // gives_ownership은 내부에서 string을 생성해서 ownership을 s1으로 이전합니다.

  let s2 = String::from("hello"); // s2를 선언합니다.

  let s3 = takes_and_gives_back(s2); // s2의 ownership이 s3로 이전됩니다.
}

fn gives_ownership() -> String {
  let some_string = String::from("yours");
  some_string
}

fn takes_and_gives_back(a_string: String) -> String {
  a_string
}
```

변수의 ownership은 매번 같은 패턴을 따릅니다 : 다른 변수에 할당될 때 이전된다.
힙에 있는 데이터를 포함하는 변수가 스코프를 벗어나면, 그 데이터의 소유권이 다른 변수로 이동하지 않는 한 `drop`에 의해 값이 정리됩니다.

이런 방식이 동작하긴 하지만, 함수가 소유권을 가져갔다가 다시 반환하는 것은 다소 번거롭습니다. 만약 함수가 값을 사용하되, 소유권을 가져가지 않게 하려면
값을 다시 사용하고 싶을 때, 함수에 전달한 모든 것을 다시 반환 받아야합니다.

```rust
fn main() {
  let s1 = String::from("hello");

  let (s2, len) = calculate_length(s1);

  println!("length of s2 is {len}");
}

fn calculate_length(s: String) -> (String, usize) {
  let length = s.len();
  (s, length)
}
```

이런 방식은 너무 번거롭기에, rust는 ownership을 이전하지 않는 reference라는 feature를 사용합니다.

### reference and borrowing

`reference`는 포인터와 유사합니다. 포인터와 다른 점은 레퍼런스는 레퍼런스의 생명 주기 동안 유효한 값을 가리키는 것이 보장됩니다.

```rust
fn main() {
  let s1 = String::from("hello");

  let len = calculate_length(&s1);

  println!("length of {s1} is {len}");
}

fn calculate_length(s: &String) -> usize {
  s.len()
}
```

앞서 작성한 것보다 깔끔한 코드가 작성되었습니다. 다른 점은 `&s1`이 함수 파라미터로 전달되고, 함수 시그니처의 파라미터 타입이 `&String`으로 변경된 것을
확인할 수 있습니다. 
![https://doc.rust-lang.org/book/img/trpl04-05.svg](https://doc.rust-lang.org/book/img/trpl04-05.svg)

> `&`이 reference를 나타냅니다. `*`는 dereference를 나타냅니다.

작성한 코드를 좀 더 분석해보면
```rust
let s1 = String::from("hello");
let len = calculate_length(&s1);
```

`&s1`은 `s1`의 값에 대한 `참조`를 생성합니다. 참조를 생성하는 것이지, **ownership을 가질 수는 없습니다.** 
ownership을 가지지는 않기에 레퍼런스의 사용이 중단 되어도 point하는 값은 drop되지 않습니다.

함수 시그니처에서도 `&` 을 사용해서 레퍼런스를 받는 다는 것을 나타냅니다.
```rust
fn calculate_length(s: &String) -> usize { // s는 String의 레퍼런스입니다.
  s.len()
} // s의 스코프는 종료되지만, ownership은 없기에 s가 레퍼런스하는 값은 drop되지 않습니다.
```

`s`는 ownership을 가지지 않기에 `s`의 스코프가 종료되어도 실제 값은 drop되지 않습니다.
레퍼런스를 생성하는 행위를 `borrowing`이라고 부릅니다. 실생활에서 물건을 빌리면 다시 돌려줘야하는 것처럼, 레퍼런스는 ownership을 소유하지 않습니다.

만약 borrow한 값을 변경하려면 어떤 일이 일어날까요? -> 오류가 발생하고 제대로 동작하지 않습니다.
```rust
fn main() {
  let s = String::from("hello");
  change(&s);
}

fn change(s: &String) {
  s.push_str(", world");
}
```

```text
error[E0596]: cannot borrow `*s` as mutable, as it is behind a `&` reference
 --> borrow.rs:7:5
  |
7 |     s.push_str(", world");
  |     ^ `s` is a `&` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
6 | fn change(s: &mut String) {
  |               +++

error: aborting due to 1 previous error

For more information about this error, try `rustc --explain E0596`.
```

변수가 기본적으로 불변인 것처럼, reference또한 불변입니다.

### mutable references

작성한 코드를 조금 변경해서 mutable reference를 사용할 수 있습니다.

```rust
fn main() {
  let mut s = String::from("hello");
  
  change(&mut s);
}

fn change(s: &mut String) {
  s.push_str(", world");
}
```

먼저 `s`를 가변 변수로 선언해야합니다.
그리고 `&mut s`을 이용해서 mutable reference를 생성합니다. 
`change`함수의 시그니처도 `&mut String`으로 변경합니다.

mutable reference는 하나의 큰 제한사항이 있습니다.
만약 어떤 값에 mutable reference가 존재한다면, 다른 reference는 존재할 수 없습니다.

다음 코드는 컴파일되지 않습니다.
```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{r1}, {r2}")
}
```

```text
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> mutable_reference.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{r1}, {r2}")
  |               ---- first borrow later used here

error: aborting due to 1 previous error

For more information about this error, try `rustc --explain E0499`.

```

에러 메시지를 확인해보면 `s`를 mutable reference로 2번 빌릴 수 없다는 내용을 확인할 수 있습니다. 
첫번째 mutable reference borrow는 `r1`의 생성 시점에 발생하고 `println!`까지 지속됩니다. 
mutable reference의 생성과 이용 사이에 새로운 mutable reference borrow가 발생합니다.

동일한 데이터에 대해 동시에 여러 개의 가변 참조를 허용하지 않는 제한은 매우 통제된 방식으로 변경을 허용합니다.
대부분의 언어는 언제든지 데이터를 변경할 수 있도록 하기 때문에, 새로운 rust 사용자들은 이런 부분에서 어려움을 겪곤 합니다.
이런 제한의 장점은 rust가 컴파일 시점에 데이터 병합을 방지할 수 있다는 점입니다.

데이터 경합은 경쟁 조건과 유사하며, 다음 3 가지 동작이 발생할 때 일어납니다.
- 2개 혹은 그 이상의 포인터가 같은 데이터를 같은 시점에 접근할 수 있을 때
- 적어도 하나의 포인터가 데이터를 변경 가능할 때
- 데이터 접근에 동기화 메커니즘이 적용되지 않을 때

데이터 경합은 예상치 못한 동작을 발생시키고, 원인을 분석하고, 고치기 어렵습니다. rust는 이런 문제를 컴파일 시점에 방지해줍니다.

항상 그렇듯이, 새로운 스코프를 이용해서 여러개의 mutable reference를 선언할 수 있습니다.
```rust
fn main() {
  let mut s = String::from("hello");
  {
    let r1 = &muts;
  } // r1의 스코프는 종료되기에 다른 mutable reference를 생성할 수 있습니다.
  let r2 = &mut s;
}
```

mutable reference와 immutable reference을 혼합할 때도, 비슷한 규칙을 강제합니다.
```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    let r3 = &mut s;

    println!("{r1}, {r2}, {r3}")
}

```

```text
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> mutable_reference.rs:6:14
  |
4 |     let r1 = &s;
  |              -- immutable borrow occurs here
5 |     let r2 = &s;
6 |     let r3 = &mut s;
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{r1}, {r2}, {r3}")
  |               ---- immutable borrow later used here

error: aborting due to 1 previous error

For more information about this error, try `rustc --explain E0502`.
```

immutable reference가 존재할 때, mutable reference도 선언할 수 없습니다.

immutable reference를 사용할 때, 값이 변경될 것을 예상하지 않기에 immutable reference가 존재할 때 mutable reference를 선언할 수 없습니다.

reference의 스코프는 선언된 시점부터, 마지막으로 reference가 사용된 시점까지 입니다. 다음과 같은 코드는 문제 없이 실행됩니다.
```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    println!("{r1} {r2}");
    // r1과 r2는 이 시점 이후에 사용되지 않기에 reference scope가 끝납니다.
    
    let r3 = &mut s;
    println!("{r3}");
}

```

borrowing error는 몇몇 경우 좌절스럽기도 하지만, 런 타임 시점에 발생할 수 있는 에러를 컴파일 타임에 잡아주는 것임을 기억해야 합니다.

### dangling reference

포인터를 사용하는 몇몇 언어에서는 dangling pointer를 생성하기 쉽습니다.
> dangling pointer : 다른 곳에 할당된 메모리 위치를 참조하는 잘못된 포인터

반면 rust에서는 컴파일러가 참조가 dangling 참조가 되지 않도록 보장해 줍니다.
```rust
fn main() {
    let reference_to_nothing = dangle();

}

fn dangle() -> &String {
    let s = String::from("hello");
    &s
}

```

```text
error[E0106]: missing lifetime specifier
 --> dangling.rs:6:16
  |
6 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
6 | fn dangle() -> &'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
6 - fn dangle() -> &String {
6 + fn dangle() -> String {
  |

warning: unused variable: `reference_to_nothing`
 --> dangling.rs:2:9
  |
2 |     let reference_to_nothing = dangle();
  |         ^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_reference_to_nothing`
  |
  = note: `#[warn(unused_variables)]` on by default

error[E0515]: cannot return reference to local variable `s`
 --> dangling.rs:8:5
  |
8 |     &s
  |     ^^ returns a reference to data owned by the current function

error: aborting due to 2 previous errors; 1 warning emitted

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.

```

아직 학습하지 않은 개념이지만, 코드의 문제를 확인해볼 수 있는 에러 메시지가 있습니다.
```text
 this function's return type contains a borrowed value, but there is no value for it to be borrowed from
```

`dangle`의 코드를 좀 살펴보면
```rust
fn dangle() -> &String { // String의 레퍼런스를 리턴합니다.
  let s = String::from("hello"); // s는 새로운 String 입니다.
  &s // s의 레퍼런스를 리턴하는데
} // 여기서 s의 스코프는 끝나서 s의 메모리는 휘발되기에 문제가 되는 상황이 발생합니다.
```

이런 경우에는 String 값을 리턴하는 것으로 문제를 해결할 수 있습니다.
```rust
fn no_dangle() -> String {
  let s = String::from("hello");
  s
}
```


