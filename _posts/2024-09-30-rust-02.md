---
layout: post
title: rust.02
date: 2024-09-30 17:35 +0900
description: rust collections, error handling, generic, test
image:
category: ["rust"]
tags:
published: true
sitemap: true
author: kim-dong-jun99
---
## collections

### Vectors

첫번째로 다룰 컬렉션 타입은 `Vec<T>`입니다. 
Vectors는 한가지 데이터 타입의 여러 데이터들을 메모리에 저장할 수 있습니다.

새로운 빈 Vector는 다음과 같이 생성할 수 있습니다.
```rust
let v: Vec<i32> = Vec::new();
```

Vector를 생성할 때 타입 정보를 넘기고 있는 것을 확인할 수 있습니다.
Vector를 생성할 때, Vector에는 아무런 값도 들어있지 않으므로, rust에 어떤 타입을 저장하려고 Vector를 만들었는지를 알려줘야합니다.

종종 `Vec<T>`를 초기 값을 가진 상태로 선언하기도 하는데 이때는 rust는 Vector 내부에 포함된 값으로부터 타입을 유추하게 됩니다.
rust는 `vec!`매크로를 제공하는데, 이를 이용해서 초기 값을 가진 Vector를 생성할 수 있습니다.
```rust
let v = vec![1,2,3]; // Vec<i32>
```

Vector를 생성하고 아이템을 추가하기 위해서는 `push`메소드를 사용해야합니다.
```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
```

변수들과 마찬가지로, `mut`키워드를 사용해 `v` 값을 변경가능하게 선언해야합니다.
그리고 Vector에 추가하는 모든 값들이 `i32`이기에 타입 어노테이션이 필요 없습니다.

Vector에 저장된 값을 읽는데에는 2가지 방법이 있습니다.
- indexing
- `get` method

```rust
let v = vec![1,2,3];

let third: &i32 = &v[2];
println!("third element is {third}");

let third: Option<&i32> = v.get(2);
match third {
  Some(third) => println!("third element is {third}"),
  None => println!("there is no third element"),
}
```
`&`와 `[]`을 사용해서 인덱스 값에 대한 reference를 리턴 받을 수 있습니다.
`get`메소드를 사용하면 `Option<&T>`를 리턴받고, match를 사용해서 값을 꺼낼 수 있습니다.

rust는 엘리멘트를 레퍼런스하는 두 가지 방법을 지원하기에 프로그램이 어떻게 동작하기를 바라는지에 따라서 선택할 수 있습니다.

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

첫번째 `[]`는 런타임 오류를 발생시킵니다. 존재하지 않은 값을 레퍼런스하기 때문입니다.
만약 존재하지 않는 값을 참조했을 때 프로그램이 실행 중단되야하면 사용하기 좋은 메소드입니다.

`get`메소드를 사용하면 런타임 오류를 발생하지 않고 `None`을 리턴합니다.
Vector의 범위 바깥 값을 종종 접근해야될 때 이러한 방법을 쓰는 것이 좋습니다.

Vectotr 역시 마찬가지로 mutable, immutable reference의 규칙을 따라야합니다.
```rust
let mut v= vec![1,2,3,4,5,];
let first = &v[0];
v.push(6);
println!("first is {first}");
```
위 코드는 에러를 발생시킵니다.
`first` 엘리멘트가 immutable reference로 선언되었기에, `first`의 값을 출력하고 Vector에 값을 추가해야 정상적으로 동작합니다.

다음과 같이 vector를 순회할 수 있습니다.
```rust
let v = vec![100, 32, 57];
for  in in &v {
  println!("{i}");
}
// 값을 변경해야한다면, 다음과 같이 작성할 수 있습니다.
for i in &mut v {
  *i += 50;
}
```

mutable reference가 참조하는 값을 변경하기 위해서는 `*`dereference 오퍼레이터를 사용해야합니다.

Vector는 같은 타입의 값들만 저장할 수 있는데, enum을 사용하면 다양한 값들을 저장할 수 있습니다.

```rust
enum SpreadsheetCell {
  Int(i32),
  Float(f64),
  Text(String),
}

let row = vec![
  SpreadsheetCell::Int(3),
  SpreadsheetCell::Text(String::from("blue")),
  SpreadsheetCell::Float(10.12),
];
```

enum들은 같은 타입을 가지기에, enum 타입에 다양한 값을 가지게 선언해서 다양한 타입 값을 저장하는 Vector를 사용할 수 있습니다.

### Strings

새로 rust를 학습하는 사람들은 3가지 이유들로 인해 string에 어려움을 겪습니다.
- rust의 발생 가능한 오류를 노출하는 특성
- string이 알려진 것보다 더 복잡한 자료구조
- UTF-8

위 3가지 이유가 혼합되어 다른 프로그래밍 언어를 사용하다 넘어온 사람들이 어려움을 겪습니다.

**String이 무엇인가**

먼저 string이라는 표현이 무엇을 의미하는지 정의해야합니다.
rust는 내부적으로 `str`이라는 단 하나의 string slice 타입을 가지고 있습니다.
string literal 들도 모두 다 string slice들로 저장됩니다.

`String`타입은 rust의 표준 라이브러리가 제공하는 타입으로 변형 가능한, UTF-8로 인코딩된 문자열 타입입니다. 

`str`, `String` 두 타입 모두 rust에서는 "strings"이고 다양한 표준 라이브러리에서 널리 쓰입니다.

**새로운 문자열 생성하기**

`Vec<T>`에서 가능했던 많은 것들이 `String`에서도 사용가능합니다.
다음과 같이 새로운 `String`을 생성할 수 있습니다.
```rust
let mut s = String::new();
```

종종 어떤 데이터로부터 string을 시작하고 싶은 경우가 있는데, 그럴 때는 `to_string` 메소드를 사용할 수 있습니다.
```rust
let data = "initial contents";
let s = data.to_string();
let s = "initial_contents".to_string(); // 문자열 구문에서도 바로 사용 가능합니다.
```

위 코드는 `initial_contents`를 포함하는 문자열을 생성합니다.
또 기존에 사용했던 것 처럼 다음과 같이 문자열을 생성할 수도 있습니다.
```rust
let s = String::from("initial_contents");
```

`String`은 `Vec<T>`처럼 데이터를 변경할 수 있습니다. 

```rust
let mut s = String::from("foo");
s.push_str("bar");
```
`s`는 `foobar`이라는 값을 가집니다.
`push_str`메소드는 string slice를 파라미터로 받습니다. 왜나하면, 파라미터의 ownership을 가져갈 이유가 없기 때문입니다.

아래 코드에서 `s1`에 `s2`를 더한 이후에도 `s2`를 사용할 수 있습니다.
```rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {s2}");
```

만약 `push_str`메소드가 `s2`의 ownership을 가져갔다면, `s2`의 값을 출력할 때 오류가 발생할 것입니다.

`push` 메소드는 하나의 문자를 파라미터로 전달받아 `String`에 추가합니다.
```rust
let mut s= String::from("lo");
s.push('l');
```

기존에 존재하는 두 문자열은 `+` 연산자를 이용해 더할 수 있습니다.
```rust
let s1 = String::from("hello ");
let s2 = String::from("world");
let s3 = s1 + &s2; // s1은 이제 더 이상 쓸 수 없습니다.
```

`s3`는 `hello world`라는 값을 가지고, `s1`은 더 이상 사용할 수 없습니다.
`s1`은 이제 더 이상 사용할 수 없고, `s2`는 레퍼런스를 사용한 이유는 `+` 연산자를 사용했을 때
호출되는 메소드의 시그니처와 관련있습니다.
`+` 연산자는 `add`메소드를 사용하는데, 그 메소드 시그니처는 다음과 같습니다.
```rust
fn add(self. s: &str) -> String {

}
```

표준 라이브러리에서 `add`가 제네릭 타입을 이용해서 정의된 것을 볼 수 있는데, 위 코드는 제네릭 타입을 `String`으로 바꿔서 `String` 값으로 `add`를 호출했을 때 무슨 일이 일어나는지를 알아볼 것입니다.
위 함수 시그니처는 `+`연산자 동작 중 모호한 부분을 알기 위한 힌트를 줍니다.

먼저 `s2`는 `&`로 쓰였습니다.
`&`을 사용하면서 첫번째 문자열에 두번째 문자열의 레퍼런스를 더한다는 의미가 되는데, 그 이유는 
`add` 함수의 파라미터를 보면 알 수 있습니다.
`add` 함수의 파라미터를 보면 `&str`인 것을 확인 할 수 있는데, 그렇기에 두 문자열의 값을 더할 수 없다는 것을 알 수 있습니다.
근데 생각해보면 `&s2`의 타입은 `&str`이 아니라 `&String`인데, 어떻게 `let s3 = s1 + &s2;`가 컴파일 되는 것일까요?

`&s2`를 `add`에 사용할 수 있는 이유는, 컴파일러가 `&String` argument를 `&str`으로 강제하기 때문입니다. 
`add`메소드를 호출할 때, rust는 deref coercion을 사용합니다. 
deref coercion을 통해 `&s2`는 `&s2[..]`로 전환됩니다.
> deref coercion에 대해서는 추후에 추가적으로 다룰 것입니다.
> `add`가 파라미터 `s`의 ownership을 가져가지는 않기에, `s2`는 연산 이후에도 유효한 문자열입니다.

그리고 함수 시그니처에서 `add`는 `self`의 ownership을 가져가는 것을 알 수 있습니다. `self`는 `&`을 가지고 있지 않기 때문입니다. 그렇기에 `s1`은 `add`로 이동한 이후부터는 유효하지 않을 것입니다.
`let s3 = s1 + &s2;`가 두 문자열을 복사해서 새로운 문자열을 생성하는 것처럼 보이지만,
이 statement는 사실 `s1`의 ownership을 가져가서, `s2`의 내용물을 더하고 결과물의 ownership을 return하는 statement입니다.
다른말로, 많은 복사 작업이 일어나는 것 같지만, 사실 그렇지 않습니다.
실제 구현은 복사 작업보다 훨씬 효율적으로 이뤄집니다.

다수의 String을 더해야하면, `format!` 매크로를 사용할 수 있습니다.
`format!` 매크로는 레퍼런스를 사용하기에, 파라미터의 ownership을 가져가지 않습니다.
```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
```

많은 프로그래밍 언어에서 String indexing으로 개별 문자에 접근할 수 있습니다. 
하지만 rust에서 String에 indexing을 적용하면 오류가 발생하는 것을 알 수 있습니다.
```rust
let s1 = String::from("hello");
let h = s1[0];
```

위 코드를 실행하면 아래 에러 메시지를 확인할 수 있습니다.
```text
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --> src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `{integer}`, which is required by `String: Index<_>`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>
  = help: the trait `SliceIndex<[_]>` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index<{integer}>`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
```

`String`은 `Vec<u8>`의 wrapper입니다.
```rust
let hello = String::from("hola");
```

이 경우 `len` 값은 4입니다. `hola`문자열이 4바이트라는 의미입니다.
문자열을 구성하는 각 문자는 UTF-8로 인코딩 되어있고, 1바이트씩을 차지합니다.

```rust
    let hello = String::from("Здравствуйте");
```

위 문자열의 길이는 12처럼 보이지만, rust는 24로 응답합니다.
`Здравствуйте` 유니코드 문자열을 UTF-8로 인코딩하려면 각 유니코드 값이 2바이트 저장 공간을 차지하기 때문입니다. 그렇기에, string의 바이트가 항상 유니코드 에서는 유효하지 않습니다.

indexing을 지원하지 않는 대신, 슬라이싱은 지원합니다. 
```rust
let hello = "Здравствуйте";
let s = &hello[0..4];
```




