---
layout: post
title: microservice pattern.03
date: 2024-10-09 09:32 +0900
description: microservice patterns 책을 통해 학습한 내용을 정리한 글입니다.
image:
category: ["msa"]
tags:
published: true
sitemap: true
author: kim-dong-jun99
---

## IPC

모놀리식 애플리케이션에서 모듈은 언어 레벨 메소드 혹은 함수를 호출하기에, 클라우드 서비스와 연동하는 모듈이나 REST API를 개발하는 것이 아니면
IPC를 고려하지 않았습니다.
마이크로서비스 구조는 애플리케이션이 서비스의 집합으로 구성됩니다.
이 서비스들은 요청을 처리하기 위해 종종 협업합니다.
서비스들은 통상적으로 다수의 머신에서 실행되는 프로레스들이기에, IPC를 이용해 상호작용해야합니다.

현재 통상적으로 많이 쓰이는 IPC 메커니즘은 REST 입니다. 
REST는 모든 상황에서 최적의 솔루션은 아니기에 다른 옵션들도 신중하게 고려해야 합니다.

### overview of IPC in microservice architecture

선택할 수 있는 다양한 IPC 기술들이 존재합니다.
서비스는 synchronous request/response 기반 통신 메커니즘은 REST 혹은 gRPC를 사용할 수 있습니다.
혹은 비동기적, 메세지 기반 통신인 AMQP, STOMP를 사용할 수 있습니다.
메세지 형식도 다양하게 존재합니다.
사람이 읽을 수 있고 텍스트 기반은 JSON, XML 형식이 존재하고, Avro, Protocol Buffer 같은 바이너리 형식도 존재합니다.

**interaction styles**

서비스 API의 IPC 메커니즘을 결정하기 이전에, 서비스와 클라이언트가 상호작용하는 방식에 대해 이해해야합니다.
상호작용 스타일에 대해 먼저 고려하는 것이 요구 사항에 집중하는 대에 도움을 줍니다.

클라이언트와 서비스는 다양한 방식으로 상호작용할 수 있습니다.

|        |one-to-one|one-to-many|
|--------|----------|-----------|
|Synchronous|Request/resposne| XXXXX |
|Asynchronous|Asynchronous request/response<br>One-way notifications|Publish/subscribe<br>Publish/async responses|

- one-to-one : 각 클라이언트의 리퀘스트는 단 하나의 서비스에서 프로세스됩니다.
- one-to-many : 각 리퀘스트는 다수의 서비스에서 프로세스됩니다.
- synchronous : 클라이언트는 서비스로부터 즉각적인 응답을 기대하며, 응답을 기다리는 동안 블록될 수 있습니다.
- asynchronous : 클라이언트는 블록되지 않으며, 응답이 있더라도 반드시 즉시 전송되지는 않습니다.

다음은 one-to-one 상호작용의 타입들입니다.
- Request/response : 서비스 클라이언트는 서비스에 요청을 보내고, 응답을 기다립니다. 클라이언트는 즉각적인 응답이 오기를 기다립니다. 응답을 기다리는 동안 block될 수도 있습니다. 주로 단단하게 결합된 서비스들에서의 상호작용 방식입니다.
- Asynchronous request/response : 서비스 클라이언트는 서비스에 요청을 보내고, 서비스는 비동기적으로 응답합니다. 클라이언트는 대기하는 동안 block되지 않습니다. 서비스가 긴 시간동안 응답을 주지 않을 수도 있기 때문입니다.
- One-way notifications : 서비스 클라이언트는 서비스에 요청을 보내고, 응답을 기다리지 않고, 서비스도 응답을 보내지 않습니다.

동기식 요청/응답 상호작용 방식은 IPC 기술과 대부분 무관하다는 점을 기억하는 것이 중요합니다.
서비스는 다른 서비스와 request/response 방식을 rest 혹은 메세징을 이용해 상호작용할 수 있습니다.
두 서비스가 메세지 브로커를 이용해 통신하더라도, 클라이언트 서비스는 응답을 기다리기 위해 block 될 수 있습니다. 
그리고 이것은 서비스가 느슨하게 결합되었음을 의미하지는 않습니다.

one-to-many 상호작용 타입들은 다음과 같습니다.
- Publish/subscribe : 클라이언트가 알림 메세지를 발행합니다. 알림 메세지는 해당 메세지에 관심있는 서비스에 의해 소비됩니다.
- Publish/async responses : 클라이언트는 리퀘스트 메세지를 발행하고, 관심있는 서비스로부터 응답이 오기까지 특정 시간만큼 기다립니다.

서비스들은 통상적으로 다양한 상호작용 조합을 사용합니다. 

**defining APIs in microservice architecture**

API 혹은 인터페이스는 소프트웨어 개발의 중심이 됩니다.
애플리케이션은 모듈들로 구성됩니다. 각 모듈은 모듈의 클라이언트가 호출할 수 있는 작업들을 정의한 인터페이스를 가지고 있습니다.
잘 디자인된 인터페이스는 내부 구현의 정보를 감춘채 사용자에게 기능을 제공합니다.

모놀리식 애플리케이션에서는 인터페이스가 일반적으로 Java 인터페이스와 같은 프로그래밍 언어의 구조를 사용하여 지정됩니다.
Java 인터페이스는 클라이언트가 호출할 수 있는 메소드들을 명시합니다.
내부 구현 클래스는 클라이언트로부터 숨겨집니다.
더불어서 자바는 정적인 타입 언어이기에, 만약 인터페이스가 클라이언트와 incompatible 하게 변경된다면, 애플리케이션은 컴파일되지 않습니다.

API와 인터페이스는 마이크로서비스에서 동일하게 중요합니다.
서비스의 API는 서비스와 클라이언트 간의 계약입니다.
서비스의 API는 클라이언트가 호출할 수 있는 오퍼레이션, 서비스로부터 발행되는 이벤트로 구성됩니다.
오퍼레이션은 이름, 파라미터, 리턴 타입을 가집니다. 이벤트는 타입과 필드를 가지고, 메세지 채널로 발행됩니다.

여기서 문제는 서비스 API는 프로그래밍 언어의 구조를 사용하여 간단하게 정의되지 않는 다는 점입니다.
서비스와 클라이언트는 같이 컴파일되지 않습니다. 
만약 새로운 서비스 버전이 호환되지 않는 API로 배포된다면, 컴파일 에러가 발생하는 것이 아니라, 런타임 에러가 발생하게 됩니다.

IPC 메커니즘과는 무관하게 서비스의 API를 interface definition language를 사용해서 정교하게 정의하는 것이 중요합니다.
먼저 인터페이스 정의를 작성합니다. 그리고 클라이언트 개발자와 함께 인터페이스 정의를 리뷰합니다.
API 정의를 먼저 살펴본 이후에 서비스를 구현합니다. 이런 작업을 통해 클라이언트의 요구사항에 맞는 서비스를 개발할 수 있습니다.

API 정의의 특성은 사용 중인 IPC 메커니즘에 따라 달라집니다.
만약 메세징을 사용한다면, API는 메세지 채널로 구성됩니다.
만약 HTTP를 사용한다면, API는 URL, HTTP 동사, 그리고 리퀘스트, 리스폰스 형식으로 구성됩니다.

**evolving APIs**

API는 새로운 기능이 추가되고, 기존 기능이 수정되고, 삭제되면서 꾸준히 변화합니다.
모놀리식 애플리케이션에서 API를 변경하고 그에 맞게 호출하는 것들을 변경하는 것이 비교적 간단 명료합니다.
정적인 타입 언어를 사용하면, API를 변경하면, 컴파일 에러가 발생하고, 컴파일 에러들을 수정하는 것으로 API를 변경할 수 있습니다.

마이크로서비스 애플리케이션에서 API를 변경하는 것은 무척이나 더 어렵습니다.
서비스의 클라이언트는 다른 서비스들로 다른 팀으로부터 개발됩니다.
클라이언트는 심지어 조직 외 다른 애플리케이션이 될 수도 있습니다.
보통 모든 클라이언트가 서비스와 동시에 업그레이드하도록 강제할 수는 없습니다. 또한, 현대 애플리케이션은 유지 관리를 위해 다운되는 경우가 거의 없기 때문에, 일반적으로 서비스의 롤링 업그레이드를 수행하게 됩니다. 따라서 구버전과 신버전의 서비스가 동시에 실행되는 경우가 발생합니다.

이러한 문제를 해결하기 위한 전략을 마련하는 것이 중요합니다. API 변경 사항을 어떻게 처리할지는 변경하려는 것의 특성에 따라 달라집니다.

**Semantic versioning**

semantic versioning 는 API을 버저닝하는데 유용한 가이드입니다.
어떻게 버전 번호를 명시하고 증가하는지에 대한 규칙들로 구성됩니다.
semantic versioning 은 초기에 소프트웨어 패키지를 버저닝하기 위해 개발되었습니다.
하지만 분산 시스템에서 API를 버저닝하는데에도 사용할 수 있습니다.

semantic versioning(Semvers) 버전 번호를 3가지 파트로 구분합니다.
버전 번호의 각 부분은 다음과 같이 증가시켜야 합니다.
- MAJOR : API에 호환되지 않는 변경 사항이 있을 때
- MINOR : API에 대한 하위 호환 가능한 기능 개선이 있을 때
- PATCH : 하위 호환 가능한 버그 수정을 할 때

REST API, 메세징 같은 다양한 곳에서 semvers를 적용할 수 있습니다.
- REST API 같은 경우, 메이저 버전을 URL 경로의 첫번째 엘리멘트로 선언할 수 있습니다.
- 메세징의 경우, 버전 번호를 메세지에 포함할 수 있습니다.

이상적으로 하위 호환 가능한 기능 개선만 만드는 것이 좋습니다.
하위 호환 가능한 변경 사항들은 다음과 같은 기능을 API에 추가하는 것을 의미합니다.
- 요청에 추가적인 속성 더하기
- 응답에 추가적인 속성 더하기
- 오퍼레이션 추가하기

위와 같은 변경 사항들만 만든다면, 클라이언트는 서비스에 맞춰 변경하지 않아도 원할하게 동작합니다.
서비스는 포함되지 않은 리퀘스트 속성들에 대한 기본 값을 제공해야되며, 클라이언트는 추가적인 속성 값들을 무시해야합니다.
이런 것들이 어렵지 않게 되게하려면, 리퀘스트와 응답 형식은 [Robustness 원칙](https://en.wikipedia.org/wiki/Robustness_principle)을 따라야합니다.

**호환 가능하지 않은 변경 사항**

종종 API에 호환되지 않는 변경 사항을 만들어야될 수 있습니다.
클라이언트도 즉시 업데이트되기를 강요할 수 없기에. 서비스는 오래된 버전과 새로운 버전을 동시에 서비스해야합니다.
REST 같은 HTTP 기반 IPC 메커니즘을 사용한다면, 메이저 버전의 번호를 경로에 삽입할 수 있습니다.
> 버전 1의 경로는 `/v1/...`, 버전 2의 경로는 `/v2/...`

또 다른 옵션은 HTTP의 콘텐츠 협상 메커니즘을 사용하여 MIME 타입에 버전 번호를 포함하는 것입니다.
예를 들어, 클라이언트가 `Order`의 1.x 버전을 요청할 때 다음과 같은 요청을 보낼 수 있습니다.
```text
GET /orders/xyz HTTP/1.1
Accept: application/vnd.example.resource+json; version=1
```
이 요청은 클라이언트가 `1.x` 버전의 응답을 기대한다는 의미입니다.

API의 다양한 버전을 지원하기 위해서는, API를 구현하는 서비스의 어댑터는 오래된 버전과 새로운 버전간의 번역을 지원해야 합니다.

**message formats**

IPC의 본질은 메세지의 교환입니다.
메시지에는 보통 데이터가 포함되며, 중요한 설계 결정 중 하나는 해당 데이터의 형식을 결정하는 것입니다.
메세지의 형식을 결정하는 것은 IPC의 효율성, API의 사용 편의성, 그리고 API의 확장 가능성에 영향을 미칩니다.
만약 메세징 시스템을 사용하거나, HTTP 같은 프로토콜을 사용하면, 사용할 메세지 형식을 선택할 수 있습니다.
gRPC 같은 메커니즘 메세지 형식을 지정할 수도 있습니다.
어느 경우든, 언어 간 호환이 가능한 메시지 형식을 사용하는 것이 필수적입니다.

메세지 형식에는 크게 두가지 카테고리가 존재합니다 : 텍스트 기반, 바이너리 기반

**text based message formats**

첫번째 카테고리는 JSON, XML 같은 텍스트 기반 형식입니다. 
이런 형식의 장점은 사람이 읽을 수 있을 뿐만 아니라, 자체적으로 구조를 설명할 수 있다는 점입니다.
JSON 메세지는 이름이 지정된 속성의 모음입니다. 
유사하게, XML 메시지도 사실상 이름이 지정된 요소와 값의 모음입니다.
이러한 형식은 **메시지의 소비자가 관심 있는 값을 선택하고 나머지는 무시할 수 있도록 해줍니다.**
결과적으로 메시지 스키마에 대한 많은 변경이 쉽게 하위 호환성을 유지할 수 있습니다.

텍스트 기반 형식의 단점은, 좀 글이 길어진다는 단점이 있습니다.
모든 메시지 프로퍼티의 이름을 포함해야하는 오버헤드가 발생합니다.
또 다른 단점은 텍스트를 파싱하면서 발생하는 오버헤드입니다.
만약 성능이 중요하다면, 바이너리 형식을 고려할 수 있습니다.

**binary message formats**

선택할 수 있는 다양한 바이너리 형식이 존재합니다.
인기있는 형식으로는 [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview), [Avro](https://avro.apache.org)가 존재합니다.
두 형식 모두 메세지 형식을 정의하기 위한 타입 IDL을 제공합니다.
그런 다음 컴파일러는 메세지를 직렬화하고 역직렬화하는 코드를 생성합니다.
API 중심의 접근 방식을 서비스 설계에 강제로 적용해야 합니다! 게다가, 클라이언트를 정적 타입 언어로 작성하면 컴파일러가 API를 올바르게 사용하고 있는지 검사합니다.

두가지 바이너리 형식 간의 차이점은 Protocol Buffers는 태그된 필드를 사용하고, Avro는 스키마를 알아야 메세지를 해석할 수 있습니다.
그렇기에, Protocol Buffers를 이용해 API의 발전에 대응하는 것이 더 쉽습니다.

### Remote procedure Invocation pattern

remote procedure 기반 IPC 메커니즘을 사용할 때, 클라이언트는 서비스 요청을 보내고, 서비스를 요청을 처리하고, 응답을 보냅니다.
몇몇 클라이언트는 응답을 기다릴 때 block 될 수 도 있고, 다른 클라이언트는 reactive non-blocking architecture를 가질 수도 있습니다.
하지만 메세징을 사용할 때와는 다르게, 클라이언트는 리퀘스트에 대한 응답이 빠른 시간안에 도착할 것이라고 예상합니다.

Remote procedure Invocation은 다음과 같이 동작합니다.
<img width="758" alt="Screenshot 2024-10-09 at 17 56 55" src="https://github.com/user-attachments/assets/9fdc7da1-f8f6-4f05-b21d-45ce279dc598">

클라이언트의 비즈니스 로직은 RPI 프록시 어댑터 클래스를 구현한 프록시 인터페이스를 호출합니다. 
RPI 프록시는 서비스에 요청을 보냅니다.
이 요청은 서비스의 비즈니스 로직을 인터페이스를 통해 호출하는 RPI 서버 어댑터 클래스에 의해 처리됩니다.
그런 다음 RPI 프록시에게 응답을 다시 보내고, RPI 프록시는 클라이언트의 비즈니스 로직에 결과를 반환합니다.

프록시 인터페이스는 통상적으로 커뮤니케이션 프로토콜을 캡슐화합니다.
선택할 수 있는 프로토콜에는 다양한 것들이 존재합니다.
대표적으로는 REST, gRPC가 존재합니다.

**REST**

오늘날 API들은 주로 RESTful하게 디자인 됩니다.
REST는 IPC 메커니즘으로 거의 항상 HTTP를 사용합니다.

REST의 핵심 컨셉은 고객, 상품 혹은 비즈니스 오브젝트의 컬렉션을 대표하는 비즈니스 오브젝트, 리소스입니다.
REST는 HTTP 동사를 이용해서 리소스를 조종합니다.
예를 들어 GET 리퀘스트는 리소스의 representation이 xml 문서 형태 혹은 json 오브젝트 형태로 리턴됩니다.
바이너리 형식도 가능은 하지만 텍스트 기반 형식이 주로 쓰입니다.
POST 리퀘스트는 새로운 리소스를 생성하고, PUT 요청은 리소스를 업데이트하기 위해 사용합니다.

많은 개발자들은 자신의 HTTP 기반 API가 RESTful하다고 주장합니다. 하지만, 실제로 RESTful 하지 않을 수도 있습니다.

**REST maturity model**

Leonard Richardson은 REST에 매우 도움되는 maturity model을 다음과 같이 정의합니다.
- level0 : 레벨 0 서비스의 클라이언트는 HTTP POST 요청을 통해 서비스의 유일한 URL 엔드포인트를 호출합니다. 각 요청은 수행할 작업, 작업의 대상(예: 비즈니스 객체), 그리고 필요한 매개변수를 지정합니다.
- level1 : 레벨 1 서비스는 리소스의 개념을 지원합니다. 클라이언트가 리소스에 대해 작업을 수행하려면, 수행할 작업과 필요한 매개변수를 지정한 POST 요청을 보냅니다.
- level2 : 레벨 2 서비스는 HTTP 동사를 사용해서 작업을 수행합니다. GET 을 통해 데이터를 반환받고, POST로 생성, PUT으로 수정합니다. 요청의 쿼리 매개변수와 바디(있을 경우)가 이 작업의 매개변수를 지정합니다. 이를 통해 서비스는 GET 요청에 대해 캐싱과 같은 웹 인프라를 활용할 수 있습니다.
- level3 : 레벨 3 서비스는 HATEOAS(Hypertext As The Engine Of Application State) 원칙에 기반합니다. 기본 개념은 GET 요청에 의해 반환된 리소스의 표현에 해당 리소스에 대한 작업을 수행할 수 있는 링크가 포함된다는 것입니다. 예를 들어, 클라이언트는 주문을 조회한 요청에 의해 반환된 표현에 있는 링크를 통해 주문을 취소할 수 있습니다. HATEOAS의 장점은 클라이언트 코드에 URL을 하드코딩할 필요가 없다는 것입니다.

**specifying REST APIs**

앞서 설명한 것처럼, API는 IDL을 이용해서 정의해야 합니다.
REST는 근본적으로 IDL을 가지지는 않았습니다. 다행히도 개발자 커뮤니티는 RESTful APIs들의 IDL에 대해서 재발견하게되었습니다.
가장 인기있는 REST IDL은 스웨거로부터 발전된 [Open API Specification](https://www.openapis.org/) 입니다.
스웨거 프로젝트는 REST API를 개발하고 문서화하기 위한 도구들의 모음입니다.

**fetching multiple resources in a single request**

REST 리소스는 보통 고객이나 주문 같은 비즈니스 오브젝트로부터 유래됩니다.
결과적으로 REST API를 디자인할 때 자주 등장하는 문제는 어떻게 클라이언트로 하여금 한번의 요청으로 연관된 다수의 오브젝트를 반환받게 할 것인가 입니다.
예를 들어, REST 클라이언트가 주문과 주문의 고객을 리턴받고 싶어하는 상황입니다.
순수한 REST API는 클라이언트로 하여금 최소 2번의 요청을 하게 할 것입니다. 한번은 주문, 또 한번은 고객.
보다 더 복잡한 시나리오는 더 많은 round trip을 발생시킬 것입니다.

이런 문제를 해결할 수 있는 한가지 방법은 클라이언트로 하여금 리소스를 받을 때 연관된 리소스도 받는 것을 허용하는 것입니다.
예를 들어 클라이언트는 주문과 고객을 `GET /orders/order-id-1345?expand=consumer`로 받을 수 있습니다.
쿼리 파라미터는 주문과 함께 리턴될 리소스를 명시합니다. 이런 접근은 많은 시나리오에서 적합하게 동작하지만, 여전히 복잡한 시나리오에서 적용하기는 아쉽습니다.
이런 문제는 [GraphQL](https://graphql.org/)과 [Netflix Falcor](https://netflix.github.io/falcor/) 같은 효율적인 데이터 fetching을 지원하는 대체 API 기술의 인기를 증가시켰습니다.

**mapping operations to HTTP verbs**

또다른 REST API 디자인 문제는 어느 오퍼레이션을 어느 HTTP 동사와 매핑할 것인지 입니다.
REST API는 PUT을 이용해 업데이트를 수행해야합니다. 하지만 주문을 업데이트하는 데에는 다양한 방법이 존재합니다.
주문은 취소될 수도 있고, 수정될 수도 있습니다. 또한 업데이트가 반드시 멱등성을 가지지 않을 수 있는데, PUT을 사용하려면 멱등성이 요구됩니다.
한 가지 솔루션은 리소스의 특정 부분을 업데이트할 때 서브 리소스를 정의하는 것 입니다.
주문 서비스를 예로 들면, `POST /orders/{orderId}/cancel`은 취소 요청의 엔드포인트이고, `POST /orders/{orderId}/revise`는 수정의 엔드포인트입니다.
오퍼레이션과 HTTP 동사를 연결짓는 것은 gRPC 같은 REST의 대안의 인기를 증가시켰습니다.

REST의 장점과 단점을 정리하면 다음과 같습니다.
- 장점
  - 심플하고 익숙하다.
  - HTTP API를 브라우저나 커맨드 라인 툴을 이용해 테스트할 수 있다.
  - 즉각 적으로 request, response 형식 소통을 지원한다.
  - 방화벽 친화적입니다.
  - 중간 브로커를 필요로 하지 않아 시스템 아키텍처가 단순해집니다.
- 단점
  - request, response 형식 소통만 지원합니다.
  - 가용성이 줄어들게 됩니다. 클라이언트와 서비스가 메시지를 버퍼링할 중간 매개체 없이 직접 통신하므로, 교환 기간 동안 두 시스템 모두 가동되어 있어야 합니다.
  - 클라이언트는 서비스 인스턴스들의 위치(URL)를 알아야합니다. 현대 애플리케이션에서 이는 사소하지 않은 문제입니다.
  - 단일 요청으로 여러 리소스를 가져오는 것이 어렵습니다.
  - 여러 업데이트 작업을 HTTP 동사에 매핑하는 것이 때때로 어렵습니다.


